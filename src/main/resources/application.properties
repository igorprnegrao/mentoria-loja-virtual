spring.application.name=loja-virtual
spring.datasource.url=jdbc:postgresql://localhost:5432/loja-virtual?autoreconnect=true
spring.datasource.username=postgres
spring.datasource.password=C@r@lho828385
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults = true
spring.jpa.database-platform = org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibrnate.dialect = org.hibernate.dialect.PostgreSQLDialect

server.servlet.context-path=/loja_virual_mentoria

spring.servelet.multipart.max-file-size=10000kb
spring.servelet.multipart.max-request-size=10000kb
spring.servelet.multipart.enable=true

#As configurações que você forneceu habilitam e ajustam a compressão de respostas HTTP e o uso do protocolo HTTP/2 em um servidor Spring Boot.

#Esta linha ativa a compressão GZIP para as respostas HTTP. A compressão reduz o tamanho dos dados transferidos do servidor para o cliente (navegador), o que pode melhorar a velocidade de carregamento de páginas e a eficiência da banda.
server.compression.enabled=true
#Define quais tipos de conteúdo (MIME types) devem ser comprimidos.Na lista, você incluiu tipos comuns como text/html, application/json e application/javascript, garantindo que os arquivos mais importantes para o frontend, como páginas HTML, folhas de estilo CSS, scripts JavaScript e dados JSON, sejam comprimidos.
server.compression.mime-types=text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json
#Especifica o tamanho mínimo (em bytes) que uma resposta deve ter para ser comprimida. Respostas menores que 1KB não serão comprimidas, pois o ganho de desempenho não justificaria o custo de processamento da compressão.
server.compression.min-response-size=1024
#Ativa o protocolo HTTP/2. O HTTP/2 traz melhorias significativas em relação ao HTTP/1.1, como multiplexação (múltiplas requisições e respostas em uma única conexão), server push e compressão de cabeçalhos. Usar HTTP/2 junto com a compressão de GZIP pode melhorar ainda mais o desempenho da sua aplicação.
server.http2.enabled=true

#configura um pool de conexões com o banco de dados usando HikariCP, que é o padrão no Spring Boot. Define explicitamente o HikariCP como o tipo de pool de conexões.
spring.datasource.type=com.zaxxer.hikari.HikariDataSource
#Define o tempo máximo, em milissegundos (20 segundos), que uma aplicação irá esperar para obter uma conexão do pool. Se uma conexão não estiver disponível dentro desse período, uma exceção será lançada.
spring.datasource.hikari.connection-timeout=20000
#Define o número mínimo de conexões ociosas (idle) que o pool tentará manter. O pool se expandirá até o maximum-pool-size se a demanda for alta, mas sempre tentará manter pelo menos 200 conexões prontas para uso.
spring.datasource.hikari.minimum-idle=200
#Define o número máximo de conexões que o pool pode ter. Isso inclui conexões em uso e ociosas. O pool nunca excederá esse limite.
spring.datasource.hikari.maximum-pool-size=550

#tempo oscioso para conexão

#Esta propriedade define o tempo máximo, em milissegundos, que uma conexão pode ficar ociosa no pool sem ser utilizada antes de ser encerrada. O valor 10000 significa 10 segundos. Se uma conexão estiver ociosa por mais de 10 segundos, o HikariCP a fechará para liberar recursos. O valor padrão é 600.000 (10 minutos), e um valor muito baixo pode fazer com que conexões sejam fechadas e reabertas frequentemente, o que não é ideal.
spring.datasource.hikari.idle-timeout=10000
#Esta propriedade define um nome personalizado para o seu pool de conexões. Por padrão, o nome é algo genérico como HikariPool-1. Dar um nome específico, como PoolHikari, é útil para monitoramento e logging, pois facilita a identificação do pool nos logs e ferramentas de monitoramento. Isso é especialmente útil se você tiver múltiplos pools de conexões em sua aplicação.
spring.datasource.hikari.pool-name=PoolHikari

#salvando dados no banco automaticamente
spring.datasource.hikari.auto-commit=false
server.servlet.session.timeout=240m
spring.transaction.rollback-on-commit-failure=true
spring.jpa.properties.hibernate.jdbc.batch_size=4
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
server.tomcat.max-connections=50000
server.tomcat.threads.min-spare=1000
spring.session.jdbc.cleanup-cron=0 0 4 * * *

spring.mvc.static-path-pattern=/resoures/static/**

